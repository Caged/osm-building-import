#!/usr/bin/env node

// Generate a png image from a query
//
// - q: Query to run
// - d: Name of database
// - o: Name of png file to write
//
// Examples:
//  script/rasterize -q 'select st_asgeojson(geom) as feature from buildings \
//    where st_isvalid(geom) order by gid desc limit 100000' -d pdx_osm \
//    -o out.png

var fs = require("fs"),
    d3 = require("d3"),
    Canvas = require("canvas"),
    pg       = require('pg'),
    argv = require('minimist')(process.argv.slice(2))

if(!argv.o || !argv.d || !argv.q || !argv.t) {
  console.log("Please supply at least the following options\n-o file.png" +
  "\n-d database\n-q query\n-t table for bounding box");
  return
}

var out       = argv.o,
    database  = argv.d,
    query     = argv.q

var file = fs.createWriteStream(out),
    width = 1000
    height = 1000

var canvas = new Canvas(width, height),
    context = canvas.getContext('2d');

context.fillStyle = '#111'
context.fillRect(0, 0, width, height)

context.fillStyle = '#d024a8'
context.strokeStyle = 'red'
context.lineWidth = 0.5
context.lineJoin = 'round'
context.antialias = 'subpixel'

var projection = d3.geo.albers().rotate([120])
  .scale(1)
  .translate([ 0, 0 ])

var path = d3.geo.path()
    .projection(projection)
    .context(context)
    .pointRadius(1)

// Called when postgres commands fails.  Prints the error message and
// causes the client to exit
//
// Returns nothing
var fail = function(client, err) {
  console.log(err)
  client.end()
}

// Generate a proper GeoJSON feature from a geometry
//
// geom - Polygon, Point, or any other valid GeoJSON geometry
//
// Returns an Object
var toFeature = function(geom) {
  return {
    type: 'Feature',
    properties: {},
    geometry: geom
  }
}


pg.connect("postgres://@localhost/" + database, function(err, client, done) {
  if(err) return fail(client, err)

  // Use the given query as a subquery for the bbox so the image is cropped tight
  // to the features returned by the query
  var bboxq = "with features as (" + query + ") select st_asgeojson(st_extent(st_geomfromgeojson(feature))) as extent from features"

  client.query(bboxq, function(err, result) {
    if(err) return fail(client, err)

    var bbox = JSON.parse(result.rows[0].extent)
    projection.scale(1).translate([0, 0])
    var b = path.bounds(toFeature(bbox))
    var s = .99 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height)
    var t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2]
    projection.scale(s).translate(t)

     client.query(query, function(err, results) {
       results.rows.forEach(function(feature) {
         context.beginPath()
         feature = toFeature(JSON.parse(feature.feature))
         path(feature)
         if (feature.geometry.type && /Point$/.test(feature.geometry.type)) context.stroke();
         else context.fill();
       })

       client.end()
       canvas.pngStream().pipe(file)
     })
  })
})
